# nftables buffer overflow vulnerability (CVE-2023-0179)

## Contents
1. [Literature and Resources](#project-literature-and-research-resources)
2. [Tasks](#tasks)
3. [Emulating kernel](#emulating-vulnerable-kernel-using-qemu)  
3.1 [Obtaining vulnerable kernel version](#1-download-the-vulnerable-kernel-version)  
3.2 [Install QEMU](#2-install-qemu)  
3.3 [Build kernel](#3-build-kernel)  
3.4 [Create image for kernel](#4-create-image-for-kernel)  
3.5 [Run the kernel](#5-run-the-kernel)  
3.6 [Login to QEMU terminal](#6-login-to-qemu-terminal)

## Project literature and research resources: 
CVE report thread:  
```
https://groups.google.com/g/syzkaller/c/YRNDJBsJn_s?pli=1
```
CVE description and mitigation:
```
https://access.redhat.com/security/cve/cve-2023-0179
```
Exploit script:
```
https://github.com/TurtleARM/CVE-2023-0179-PoC
```
Explanation:
```
https://ethicalhacking.uk/cve-2023-0179-a-buffer-overflow-vulnerability-in-the-linux-kernel/#gsc.tab=0
```

### Tasks:

1. Understand the vulnerability from the write-up. It's quite detailed. Take note of which versions are vulnerable.

2. Find a kernel to study, uncompress it, load it in Binary Ninja

3. Find the vulnerable function(s). I don't know if there are function names. If there are, great. If not, you can try https://github.com/marin-m/vmlinux-to-elf

4. Verify whether the vulnerability is there or not

5. Repeat to analyse one vulnerable and one not vulnerable version.

6. Test 10 functions in disassembled kernel using sidekick renaming functiona nd log the outputs. Verify if the renamed output is accurate and rate the usefulness of the output.

## Emulating vulnerable kernel using QEMU:
### 1. Download the vulnerable kernel version  
Clone from git:  
```
git clone --depth 1 --branch v6.2-rc1 https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git linux-6.2-rc1

```
### 2. Install QEMU
```
sudo apt-get update
sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison qemu-system-x86
```
### 3. Build kernel
Build and compile the kernel from source that we obtained in step 1.  
``` 
# Enter the kernel source folder
cd linux-6.2-rc1
# From inside the linux-6.2-rc1 folder, make a .config file
make defconfig
```
Check if the make worked using `cat .config | grep KVM` command.  
You should see something like:
```
CONFIG_KVM_GUEST=y
CONFIG_HAVE_KVM=y
# CONFIG_KVM is not set
CONFIG_PTP_1588_CLOCK_KVM=y
```
Add some debug configurations to the Kernel, KASAN, debug symbols, etc.  
Open `.config` and append the code below to the bottom of the `.config` file.
```
# Coverage collection.
CONFIG_KCOV=y

# Debug info for symbolization.
CONFIG_DEBUG_INFO=y

# Memory bug detector
CONFIG_KASAN=y
CONFIG_KASAN_INLINE=y

# Required for Debian Stretch
CONFIG_CONFIGFS_FS=y
CONFIG_SECURITYFS=y
```
Regenerate the configurations with the necessary modifications.
```
make olddefconfig
```
Now we are ready to build the kernel, this process might take awhile.
```
make -j`nproc`
```
If the build was successful, you should see a `bzImage` file created in `arch/x86_64/boot` folder.  inux-6.2-rc1o boot into.  
### 4. Create image for kernel
The kernel needs a filesystem to boot into.
I created a Debain-like environment by following [this online guide](https://vccolombo.github.io/cybersecurity/linux-kernel-qemu-setup/#creating-an-image-for-the-kernel:~:text=Creating%20an%20image,Permalink)  
Use the following script, it will take awhile.
```
# In the linux-6.2-rc1 folder
sudo apt-get install debootstrap
mkdir image && cd image
wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh
chmod +x create-image.sh
./create-image.sh
```
If the image creation process was successful, in `linux-6.2-rc1/image` folder, you should see `bullseye.img`, which is your file system.  
### 5. Run the kernel
Create a `run.sh` shell script file in `linux-6.2-rc1` folder with your favorite text editor.  
In the run.sh file paste the following code:
```
qemu-system-x86_64 \
        -m 2G \
        -smp 2 \
        -kernel $1/arch/x86/boot/bzImage \
        -append "console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0 nokaslr" \
        -drive file=$2/bullseye.img,format=raw \
        -net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \
        -net nic,model=e1000 \
        -enable-kvm \
        -nographic \
        -pidfile vm.pid \
        2>&1 | tee vm.log
```
Save and exit `run.sh` file.
Run the `run.sh` script:
```
chmod +x run.sh
./run.sh . image/
```
### 6. Login to QEMU terminal
The login is `root`.  
There is no password.





