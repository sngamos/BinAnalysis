# nftables buffer overflow vulnerability (CVE-2023-0179)

## Contents
1. [Literature and Resources](#project-literature-and-research-resources)
2. [Tasks](#tasks)
3. [Emulating kernel (FAILED ATTEMPT)](#emulating-vulnerable-kernel-using-qemu)  
3.1 [Obtaining vulnerable kernel version](#1-download-the-vulnerable-kernel-version)  
3.2 [Install QEMU](#2-install-qemu)  
3.3 [Build kernel](#3-build-kernel)  
3.4 [Create image for kernel](#4-create-image-for-kernel)  
3.5 [Run the kernel](#5-run-the-kernel)  
3.6 [Login to QEMU terminal](#6-login-to-qemu-terminal)

## Project literature and research resources: 
CVE report thread:  
```
https://groups.google.com/g/syzkaller/c/YRNDJBsJn_s?pli=1
```
CVE description and mitigation:
```
https://access.redhat.com/security/cve/cve-2023-0179
```
Exploit script:
```
https://github.com/TurtleARM/CVE-2023-0179-PoC
```
Explanation:
```
https://ethicalhacking.uk/cve-2023-0179-a-buffer-overflow-vulnerability-in-the-linux-kernel/#gsc.tab=0
```

### Tasks:

1. Understand the vulnerability from the write-up. It's quite detailed. Take note of which versions are vulnerable.

2. Find a kernel to study, uncompress it, load it in Binary Ninja

3. Find the vulnerable function(s). I don't know if there are function names. If there are, great. If not, you can try https://github.com/marin-m/vmlinux-to-elf

4. Verify whether the vulnerability is there or not

5. Repeat to analyse one vulnerable and one not vulnerable version.

6. Test 10 functions in disassembled kernel using sidekick renaming functiona nd log the outputs. Verify if the renamed output is accurate and rate the usefulness of the output.

## Emulating vulnerable kernel using QEMU:
### 1. Download the vulnerable kernel version  
Clone from git:  
```
git clone --depth 1 --branch v6.2-rc1 https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git linux-6.2-rc1

```
### 2. Install QEMU
```
sudo apt-get update
sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison qemu-system-x86
```
### 3. Build kernel
Build and compile the kernel from source that we obtained in step 1.  
``` 
# Enter the kernel source folder
cd linux-6.2-rc1
# From inside the linux-6.2-rc1 folder, make a .config file
make defconfig
```
Check if the make worked using `cat .config | grep KVM` command.  
You should see something like:
```
CONFIG_KVM_GUEST=y
CONFIG_HAVE_KVM=y
# CONFIG_KVM is not set
CONFIG_PTP_1588_CLOCK_KVM=y
```
Add some debug configurations to the Kernel, KASAN, debug symbols, etc.  
Open `.config` and append the code below to the bottom of the `.config` file.
```
# Coverage collection.
CONFIG_KCOV=y

# Debug info for symbolization.
CONFIG_DEBUG_INFO=y

# Memory bug detector
CONFIG_KASAN=y
CONFIG_KASAN_INLINE=y

# Required for Debian Stretch
CONFIG_CONFIGFS_FS=y
CONFIG_SECURITYFS=y
```
Regenerate the configurations with the necessary modifications.
```
make olddefconfig
```
Now we are ready to build the kernel, this process might take awhile.
```
make -j`nproc`
```
If the build was successful, you should see a `bzImage` file created in `arch/x86_64/boot` folder.  inux-6.2-rc1o boot into.  
### 4. Create image for kernel
The kernel needs a filesystem to boot into.
I created a Debain-like environment by following [this online guide](https://vccolombo.github.io/cybersecurity/linux-kernel-qemu-setup/#creating-an-image-for-the-kernel:~:text=Creating%20an%20image,Permalink)  
Use the following script, it will take awhile.
```
# In the linux-6.2-rc1 folder
sudo apt-get install debootstrap
mkdir image && cd image
wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh
chmod +x create-image.sh
./create-image.sh
```
If the image creation process was successful, in `linux-6.2-rc1/image` folder, you should see `bullseye.img`, which is your file system.  
### 5. Run the kernel
Create a `run.sh` shell script file in `linux-6.2-rc1` folder with your favorite text editor.  
In the run.sh file paste the following code:
```
qemu-system-x86_64 \
        -m 2G \
        -smp 2 \
        -kernel $1/arch/x86/boot/bzImage \
        -append "console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0 nokaslr" \
        -drive file=$2/bullseye.img,format=raw \
        -net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \
        -net nic,model=e1000 \
        -enable-kvm \
        -nographic \
        -pidfile vm.pid \
        2>&1 | tee vm.log
```
Save and exit `run.sh` file.
Run the `run.sh` script:
```
chmod +x run.sh
./run.sh . image/
```
### 6. Login to QEMU terminal
The login is `root`.  
There is no password.
## Creating user account environment for PoC
After logging in as root to emulated terminal on QEMU, we need to create a user account with no privileges to test if the exploit actually works.
### Create new user account
**While logged in as root:**
```
# Creates a user account called normal user
# -m flag ensures user's home directory is created
adduser -m normaluser
```
### Install build essentials
**While logged in as root:**
```
apt install build-essential
```
### Install git
**While looged in as root:**
```
apt install git
```
### Grant permissions to normaluser
As `normaluser` still doesn't have any permissiosn, even in its own home directory, we need to grant it the permissions using root account, else we will not be able to write or execute any files while in `normaluser`.  
**While logged in as root:**  
1. First we need to navigate to `normaluser` home directory (if you r not already there)
```
cd ..
ls
```
Expected output:
```
bin   dev  home  lib32	libx32	    media  opt	 root  sbin  sys  usr
boot  etc  lib	 lib64	lost+found  mnt    proc  run   srv   tmp  var
```
2. Navigate into `home` directory
```
cd home
ls
```
EXpected output:
```
normaluser
```
3. Navigate into `normaluser` directory and check the permissions for that directory.
```
cd normaluser
```
4. Grant `normaluser` permissions over their home directory
```
chown normaluser:normaluser .
```
5. Check if `normaluser` has permissions
```
ls -ld
```
Expected output:  
You should see `normaluser` has `rwx` permissions in this directory
```
drwxr-xr-x. 3 normaluser normaluser 4096 Nov 20 08:42 .
```
### Clone exploit script
We need to clone the exploit script while logged in as `normaluser`.
1. Change user to `normaluser` from root
```
su normaluser
```
2. Clone [this repository](https://github.com/TurtleARM/CVE-2023-0179-PoC.git)
```
git clone https://github.com/TurtleARM/CVE-2023-0179-PoC.git
ls
```
If you have set everything up properly previously, you should be able to git clone the repo successfully.  
Expected output:
```
CVE-2023-0179-PoC
```
### Build the exploit
Following the guide from the [exploit repo](https://github.com/TurtleARM/CVE-2023-0179-PoC.git), we need to install some packages first.  
For that we need to log back into `root` so that we have privileges to install system wide libraries.
1. Log back into `root`
```
su
```
2. Install packages
```
apt-get install libmnl-dev libnftnl-dev
```
Now We can build the needle file as `normaluser`.
3. Log back into `normaluser`
```
su normaluser
```
4. Build needle
```
cd CVE-2023-0179-PoC
make needle
```
5. If the build succeeded you should see an ELF file called `needle`
```
file needle
```
Expected output:
```
needle: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=adde9d9702edb1612e352953a8477e16b52f93bd, for GNU/Linux 3.2.0, not strd
```


## Understanding the vulnerability
### Introduction
**Type**: Buffer overflow  
**Location**: Netfilter subsystem in linux kernel  
**Exploit details**: Overflow the buffer that stores VLAN headers in Netfilter subsystem.
**Consequence**: Allow local attacker to gain root privileges on affected system.
### VLAN header: 
**Description**: A header added to an Ethernet frame.  
**Purpose**: Identify the VLAN that the frame belongs to, ensure segmentation of network.  
**Structure**:  
  
![Alt text](Ethernet-frame.png "Ethernet frame")  
4 bytes (32 bits) inserted into Ethernet frame between source MAC address & EtherType/length field.  
Contains the following fields:  
1. **Tag Protocol Identfier (TPID)** 16 bits:  
        - Always set to `0x8100` to indicate that the frame carries VLAN information.
2. **Priority Code Point (PCP)** 3 bits:  
        - Used to prioritize traffic (value range 0~7)
3. **Drop Eligible Indicator (DEI)** 1 bit:  
        - Inicates if the frame can be dropped in case of network congestion
4. **VLAN ID** 12 bits:  
        - Identifies which VLAN this frame belongs to.  
        - 4096 (2<sup>12</sup>) possible VLAN IDs.


## Static Analysis of CVE
### Source code analysis
We are interested in then function `nft_payload_copy_vlan` found in `<kernel source directory>/net/netfilter/nft_payload.c` as that function is the vulnerable function.
```
static bool
nft_payload_copy_vlan(u32 *d, const struct sk_buff *skb, u8 offset, u8 len)
{
	int mac_off = skb_mac_header(skb) - skb->data;
	u8 *vlanh, *dst_u8 = (u8 *) d;
	struct vlan_ethhdr veth;
	u8 vlan_hlen = 0;

	if ((skb->protocol == htons(ETH_P_8021AD) ||
	     skb->protocol == htons(ETH_P_8021Q)) &&
	    offset >= VLAN_ETH_HLEN && offset < VLAN_ETH_HLEN + VLAN_HLEN)
		vlan_hlen += VLAN_HLEN;

	vlanh = (u8 *) &veth;
	if (offset < VLAN_ETH_HLEN + vlan_hlen) {
		u8 ethlen = len;

		if (vlan_hlen &&
		    skb_copy_bits(skb, mac_off, &veth, VLAN_ETH_HLEN) < 0)
			return false;
		else if (!nft_payload_rebuild_vlan_hdr(skb, mac_off, &veth))
			return false;

		if (offset + len > VLAN_ETH_HLEN + vlan_hlen)
			ethlen -= offset + len - VLAN_ETH_HLEN + vlan_hlen;

		memcpy(dst_u8, vlanh + offset - vlan_hlen, ethlen);

		len -= ethlen;
		if (len == 0)
			return true;

		dst_u8 += ethlen;
		offset = ETH_HLEN + vlan_hlen;
	} else {
		offset -= VLAN_HLEN + vlan_hlen;
	}

	return skb_copy_bits(skb, offset + mac_off, dst_u8, len) == 0;
}
```
This function is called by another function `nft_payload_eval` also found in `nft_payload.c` file.
```
void nft_payload_eval(const struct nft_expr *expr,
		      struct nft_regs *regs,
		      const struct nft_pktinfo *pkt)
{
	const struct nft_payload *priv = nft_expr_priv(expr);
	const struct sk_buff *skb = pkt->skb;
	u32 *dest = &regs->data[priv->dreg];
	int offset;

	if (priv->len % NFT_REG32_SIZE)
		dest[priv->len / NFT_REG32_SIZE] = 0;

	switch (priv->base) {
	case NFT_PAYLOAD_LL_HEADER:
		if (!skb_mac_header_was_set(skb))
			goto err;

		if (skb_vlan_tag_present(skb)) {
			if (!nft_payload_copy_vlan(dest, skb,
						   priv->offset, priv->len))
				goto err;
			return;
		}
		offset = skb_mac_header(skb) - skb->data;
		break;
	case NFT_PAYLOAD_NETWORK_HEADER:
		offset = skb_network_offset(skb);
		break;
	case NFT_PAYLOAD_TRANSPORT_HEADER:
		if (!(pkt->flags & NFT_PKTINFO_L4PROTO) || pkt->fragoff)
			goto err;
		offset = nft_thoff(pkt);
		break;
	case NFT_PAYLOAD_INNER_HEADER:
		offset = nft_payload_inner_offset(pkt);
		if (offset < 0)
			goto err;
		break;
	default:
		WARN_ON_ONCE(1);
		goto err;
	}
	offset += priv->offset;

	if (skb_copy_bits(skb, offset, dest, priv->len) < 0)
		goto err;
	return;
err:
	regs->verdict.code = NFT_BREAK;
}
```
### Setting up .config file
We need to setup the .config file to enable `CONFIG_NETFILTER`, `CONFIG_NF_TABLES`,  `CONFIG_VLAN_8021Q`, as [documented in the CVE report](https://groups.google.com/g/syzkaller/c/YRNDJBsJn_s?pli=1#:~:text=Furthermore%2C%20the%20kernel%20must%20be%20built%20with%20the%20configuration%20%60CONFIG_NETFILTER%60%2C%20%60CONFIG_NF_TABLES%60%2C%C2%A0%20%60CONFIG_VLAN_8021Q%60%20enabled%2C%20and%20the%20CAP_NET_ADMIN%20capability%20must%20be%20enabled%2C%20which%20can%20be%20accomplished%20by%20entering%20a%20new%20user%20namespace.).  
This is done using the following command:  
In kernel root directory i.e `linux-6.x.x`  
```
make menuconfig
```
This will open up the menu configurator.  
We need to configure a few things to make sure the kernel is built so that we can easily analyse it using a decompiler later.  
All the following commands are started from the `Linux/x86 6.x.x Kernel Configuration` page (the first page you see when you `make menuconfig`)  
1. Kernel hacking --> Compile-time checks and compiler options --> Debug information --> Select `Rely on the toolchina's implicit default DWARF version`  
This will ensure that the kernel will compile with debug headers so that our decompiler can identify the functions later.
2. Networking support --> Networking options --> Enable `Network packet filtering framework (Netfilter)` --> Enable `Advanced netfilter configuration` --> Core Netfilter Configuration --> Set `netfilter nf_tables support` to `M`  
This will enable `CONFIG_NF_TABLES` and `CONFIG_NETFILTER`, and will modularise the nf_tables module into a `.ko` kernel module file for easy investigation later.  
3. Networking support --> Networking options --> Set `802.1Q/802.1ad VLAN Support` to `M`  

This will enable `CONFIG_VLAN_8021Q` during compilation.  
After completing the above 3 steps, `Save` and `Exit`.  
Open `.config` file to verify the configuration was saved properly.
```
nvim .config
```
Ensure that `CONFIG_NETFILTER=y`, `CONFIG_NF_TABELS=m`, `CONFIG_VLAN_8021Q=m`.  
If the above is configured correctly proceed to next step.

### Identifying the kernel module file
Since netfilter library is compiled as a kernel module (This is set in the .config file), after the kernel is compiled, the function `nft_payload_copy_vlan` will not be found in the `vmlinux` or `bzImage` file.  
It will be compiled into a kernel module file with `.ko` format, which we then have to find.  
Use the following function to find all kernel module `.ko` files:  
In kernel root directory,
```
find . -name "*.ko"
```
Look through the output for `nf_tables.ko`  
Example output:  
```
./linux-6.1.6/net/8021q/8021q.ko
./linux-6.1.6/net/netfilter/xt_LOG.ko
./linux-6.1.6/net/netfilter/xt_nat.ko
./linux-6.1.6/net/netfilter/xt_mark.ko
./linux-6.1.6/net/netfilter/xt_MASQUERADE.ko
./linux-6.1.6/net/netfilter/xt_addrtype.ko
./linux-6.1.6/net/netfilter/nf_tables.ko
./linux-6.1.6/net/netfilter/nf_log_syslog.ko
./linux-6.1.6/net/ipv4/netfilter/iptable_nat.ko
./linux-6.1.6/fs/efivarfs/efivarfs.ko
./linux-6.1.6/drivers/thermal/intel/x86_pkg_temp_thermal.ko
```
Then verify the file type of `./linux-6.1.6/net/netfilter/nf_tables.ko` is a ELF file
```
cd net/netfilter/
file nf_tables.ko
```
Now we can put this file in Binary Ninja for analysis.
### Identifying the function in Binary Ninja
Start Binary Ninja (binja) and open the `./linux-6.1.6/net/netfilter/nf_tables.ko` file.  
In the Symbols table, Search for `nft_payload_copy_vlan`.  
You will notice that this doesnt yield any results, (which may seem weird, but I will explain this later.)  
Upon going back to the source code in file `nft_payload.c` we notice that our function of interest `nft_payload_copy_vlan` is called by another function `nft_payload_eval`.  
In binja Symbols table, search for `nft_payload_eval`, it should appear as a function.  
Navigate to `nft_payload_eval` memory address and observe the decompiled HLIL code.  
Notice that this function behaves similarly to the `nft_payload_eval` function in the source code here is some evidence:  
1. **Similar Arguments:**  
Disassembled: `arg1`, `arg2`, `arg3` roughly correspond to `const struct nft_expr *expr`, `struct nft_regs *regs`, and `const struct nft_pktinfo *pkt` in the C source code.  
2. **Variable Mapping:**  
        - `priv` in the source code corresponds to the memory accessed by `*(arg1 + offset)` in the disassembled code.  
        - `skb` corresponds to the field pkt->skb, as referenced in the source code.  
        - `dest` corresponds to the base register `r15` used for data manipulation in the disassembled code.  
3. **Function Calls:**  
        - `skb_mac_header` corresponds to `(r14 + 0xb8)` in the disassembled code.  
        - `skb_copy_bits` appears directly in both, as it's a key operation for copying data.  

From these evidence, we can conclude that these 2 functions are equivilent to each other.  
#### Verifying conclusion with LLM
Verify this conclusion with the LLM:  
**Prompt 1:** 
```
this is the source code for nft_payload_eval:
void nft_payload_eval(const struct nft_expr *expr,
          struct nft_regs *regs,

          const struct nft_pktinfo *pkt)
 
{
const struct nft_payload *priv = nft_expr_priv(expr);

const struct sk_buff *skb = pkt->skb;

u32 *dest = &regs->data[priv->dreg];

int offset;


if (priv->len % NFT_REG32_SIZE)

    dest[priv->len / NFT_REG32_SIZE] = 0;


switch (priv->base) {

case NFT_PAYLOAD_LL_HEADER:

    if (!skb_mac_header_was_set(skb))

        goto err;


    if (skb_vlan_tag_present(skb)) {

        if (!nft_payload_copy_vlan(dest, skb,

                       priv->offset, priv->len))

            goto err;

        return;

    }

    offset = skb_mac_header(skb) - skb->data;

    break;

case NFT_PAYLOAD_NETWORK_HEADER:

    offset = skb_network_offset(skb);

    break;

case NFT_PAYLOAD_TRANSPORT_HEADER:

    if (!(pkt->flags & NFT_PKTINFO_L4PROTO) || pkt->fragoff)

        goto err;

    offset = nft_thoff(pkt);

    break;

case NFT_PAYLOAD_INNER_HEADER:

    offset = nft_payload_inner_offset(pkt);

    if (offset < 0)

        goto err;

    break;

default:

    WARN_ON_ONCE(1);

    goto err;

}

offset += priv->offset;


if (skb_copy_bits(skb, offset, dest, priv->len) < 0)

    goto err;

return;
 
err:
regs->verdict.code = NFT_BREAK;
 
}
```
**Output 1:**  
```
The nft_payload_eval function processes network packet data based on the specified payload type. Here's a breakdown of its functionality:
Initialization:
Retrieves private data from the nft_expr structure.
Extracts the socket buffer (skb) from the packet information.
Sets up a destination pointer in the registers for storing the payload data.
Payload Length Check:
If the payload length is not a multiple of NFT_REG32_SIZE, it zeroes out the remainder of the destination register.
Payload Base Handling:
Link Layer Header: Checks if the MAC header is set. If a VLAN tag is present, it attempts to copy the VLAN payload.
Network Header: Calculates the offset to the network header.
Transport Header: Verifies Layer 4 protocol presence and fragment offset, then calculates the transport header offset.
Inner Header: Calculates the offset for inner headers, handling errors if the offset is negative.
Payload Copy:
Adjusts the offset by the specified payload offset.
Copies the payload data from the socket buffer to the destination register.
Error Handling:
If any checks fail, it sets the verdict code to NFT_BREAK.
If you have specific questions about this function or need further analysis, feel free to ask!
```
After providing the source code of `nft_payload_eval` function, the LLM is able to provide a detailed explanation of the function's purpose and functionality.  

**Prompt 2:**  
```
is the nft_payload_eval in the HLIL in the decompiled code the same function as the one provided by the source code above?
```
**Output 2:**  
```
The decompiled HLIL function at address 0x17710 appears to correspond to the nft_payload_eval function from the source code you provided. Both functions involve handling network packet data and include logic for different payload bases, error handling, and copying data from a packet buffer to a destination register.
However, the HLIL representation is more abstract and may not directly match the source code line-by-line due to optimizations and differences in representation. Key elements such as checking payload bases, copying data, and setting error codes are present in both, indicating they are the same function.
```
The LLM is able to identify the similarity between the decompiled HLIL code and the provided C code and identify the similarity between the functionality of both functions.  
It also provides an explanation of the abstraction of the HLIL code (which was useful to me when trying to understand abstraction and compiler inlining)  
At this stage I wanted to experiment if the LLM can identify `nft_payload_copy_vlan` even after inlining.  
**Prompt 3:**  
```
now i want to identify the function nft_payload_copy_vlan, which is called by nft_payload_eval in the source code. which function in the HLIL decompiled code corresponds to this function
```
**Output 3:**  
```
No function with name `nft_payload_copy_vlan`
It seems I can't directly access the decompiled code for nft_payload_copy_vlan. However, you can identify this function in the HLIL by looking for a call within nft_payload_eval that handles VLAN payload copying. In the HLIL, function calls are often represented by indirect calls or specific function names if recognized. You might need to look for a call that matches the context of VLAN handling within the nft_payload_eval function. If you can provide more context or details, I might be able to assist further.
```



**Prompt 4:**
```
this is the source code in c for nft_payload_copy_vlan: 
static bool
nft_payload_copy_vlan(u32 d, const struct sk_buff skb, u8 offset, u8 len)
{
int mac_off = skb_mac_header(skb) - skb->data;

u8 *vlanh, *dst_u8 = (u8 *) d;

struct vlan_ethhdr veth;

u8 vlan_hlen = 0;


if ((skb->protocol == htons(ETH_P_8021AD) ||

     skb->protocol == htons(ETH_P_8021Q)) &&

    offset >= VLAN_ETH_HLEN && offset < VLAN_ETH_HLEN + VLAN_HLEN)

    vlan_hlen += VLAN_HLEN;


vlanh = (u8 *) &veth;

if (offset < VLAN_ETH_HLEN + vlan_hlen) {

    u8 ethlen = len;


    if (vlan_hlen &&

        skb_copy_bits(skb, mac_off, &veth, VLAN_ETH_HLEN) < 0)

        return false;

    else if (!nft_payload_rebuild_vlan_hdr(skb, mac_off, &veth))

        return false;


    if (offset + len > VLAN_ETH_HLEN + vlan_hlen)

        ethlen -= offset + len - VLAN_ETH_HLEN + vlan_hlen;


    memcpy(dst_u8, vlanh + offset - vlan_hlen, ethlen);


    len -= ethlen;

    if (len == 0)

        return true;


    dst_u8 += ethlen;

    offset = ETH_HLEN + vlan_hlen;

} else {

    offset -= VLAN_HLEN + vlan_hlen;

}


return skb_copy_bits(skb, offset + mac_off, dst_u8, len) == 0;
 
}
```
**Output 4:**  
```
To identify the nft_payload_copy_vlan function in the HLIL decompiled code, you should look for a function call within nft_payload_eval that handles VLAN-related operations. Specifically, it will likely involve:
Checking Protocols: The function checks for specific Ethernet protocols like ETH_P_8021AD and ETH_P_8021Q.
Copying Bits: It uses skb_copy_bits to copy data from the socket buffer.
VLAN Header Rebuilding: It calls a function similar to nft_payload_rebuild_vlan_hdr.
In the HLIL, this might be represented by an indirect call or a direct call if the function name is resolved. Look for these operations in the HLIL code of nft_payload_eval around the VLAN handling logic. If you find a function call that matches these characteristics, it is likely the nft_payload_copy_vlan function.
```

**Prompt 5:**  
```
explain why i am not able to see the nft_payload_copy_vlan function explicitly defined in the HLIL code?
```
**Output 5:**  
```
The absence of an explicit nft_payload_copy_vlan function definition in the HLIL code can be attributed to several factors:
Inlining: The compiler might have inlined nft_payload_copy_vlan into nft_payload_eval. Inlining is an optimization where the function's code is directly inserted into the caller to reduce function call overhead, making it appear as if the function doesn't exist separately.
Optimization: Compilers often perform optimizations that can obscure function boundaries, especially for static or small functions. This can result in the function's logic being merged into the caller.
Symbol Resolution: If the binary lacks debugging symbols or if the function is static, the decompiler might not resolve the function name, leading to it being represented as an unnamed or indirect call.
Decompilation Limitations: The decompiler might not have enough information to distinguish the function due to the binary's structure or the decompiler's current capabilities.
To confirm inlining or optimization, you could look for patterns in the HLIL that match the logic of nft_payload_copy_vlan, such as VLAN header handling and skb_copy_bits usage.
```


#### Screenshots from Sidekick directly

